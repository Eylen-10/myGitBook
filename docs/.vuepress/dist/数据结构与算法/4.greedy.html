<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>贪心类型问题 | 🎈 Eylen&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    <script language="javascript" type="text/javascript" src="/myBlog/js/pgmanor-self.js"></script>
    <meta name="description" content="">
    
    <link rel="preload" href="/myBlog/assets/css/0.styles.a45e62f3.css" as="style"><link rel="preload" href="/myBlog/assets/js/app.726a4394.js" as="script"><link rel="preload" href="/myBlog/assets/js/3.1a3b197f.js" as="script"><link rel="preload" href="/myBlog/assets/js/2.a46ddd04.js" as="script"><link rel="preload" href="/myBlog/assets/js/1.122429d8.js" as="script"><link rel="preload" href="/myBlog/assets/js/12.4e24e4ef.js" as="script"><link rel="prefetch" href="/myBlog/assets/js/11.4f5b178b.js"><link rel="prefetch" href="/myBlog/assets/js/13.6b931c87.js"><link rel="prefetch" href="/myBlog/assets/js/14.02f71517.js"><link rel="prefetch" href="/myBlog/assets/js/15.e8256c67.js"><link rel="prefetch" href="/myBlog/assets/js/16.35b05031.js"><link rel="prefetch" href="/myBlog/assets/js/17.eb207749.js"><link rel="prefetch" href="/myBlog/assets/js/18.9c7fcd74.js"><link rel="prefetch" href="/myBlog/assets/js/19.0dc9fa6b.js"><link rel="prefetch" href="/myBlog/assets/js/20.e63eac83.js"><link rel="prefetch" href="/myBlog/assets/js/21.f8404853.js"><link rel="prefetch" href="/myBlog/assets/js/22.267100f2.js"><link rel="prefetch" href="/myBlog/assets/js/23.2667fb70.js"><link rel="prefetch" href="/myBlog/assets/js/24.020d84d5.js"><link rel="prefetch" href="/myBlog/assets/js/25.11728366.js"><link rel="prefetch" href="/myBlog/assets/js/26.46bf35b3.js"><link rel="prefetch" href="/myBlog/assets/js/27.25ee404c.js"><link rel="prefetch" href="/myBlog/assets/js/28.7602ee88.js"><link rel="prefetch" href="/myBlog/assets/js/29.d3cd2aeb.js"><link rel="prefetch" href="/myBlog/assets/js/30.5110cc78.js"><link rel="prefetch" href="/myBlog/assets/js/31.871794f3.js"><link rel="prefetch" href="/myBlog/assets/js/32.92de1eb1.js"><link rel="prefetch" href="/myBlog/assets/js/33.225ddc46.js"><link rel="prefetch" href="/myBlog/assets/js/34.c4e74679.js"><link rel="prefetch" href="/myBlog/assets/js/35.75efbf56.js"><link rel="prefetch" href="/myBlog/assets/js/36.41f2d1d4.js"><link rel="prefetch" href="/myBlog/assets/js/37.cc1d599a.js"><link rel="prefetch" href="/myBlog/assets/js/38.3ece83f7.js"><link rel="prefetch" href="/myBlog/assets/js/39.764a5776.js"><link rel="prefetch" href="/myBlog/assets/js/4.bff5e546.js"><link rel="prefetch" href="/myBlog/assets/js/40.3c1fbf03.js"><link rel="prefetch" href="/myBlog/assets/js/41.95c057fb.js"><link rel="prefetch" href="/myBlog/assets/js/42.74314a04.js"><link rel="prefetch" href="/myBlog/assets/js/43.ad18cb1d.js"><link rel="prefetch" href="/myBlog/assets/js/44.a58b186c.js"><link rel="prefetch" href="/myBlog/assets/js/5.12aef77b.js"><link rel="prefetch" href="/myBlog/assets/js/6.135251d1.js"><link rel="prefetch" href="/myBlog/assets/js/7.fbd2b017.js"><link rel="prefetch" href="/myBlog/assets/js/8.84c9147c.js"><link rel="prefetch" href="/myBlog/assets/js/vendors~docsearch.b096bc3b.js">
    <link rel="stylesheet" href="/myBlog/assets/css/0.styles.a45e62f3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myBlog/" class="home-link router-link-active"><!----> <span class="site-name">🎈 Eylen's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>数据结构与算法</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myBlog/数据结构与算法/1.algoMind.html" class="sidebar-link">数据结构与算法</a></li><li><a href="/myBlog/数据结构与算法/2.BT.html" class="sidebar-link">二叉树（Binary Tree）</a></li><li><a href="/myBlog/数据结构与算法/3.DP.html" class="sidebar-link">动态规划（Dynamic Programming）</a></li><li><a href="/myBlog/数据结构与算法/4.greedy.html" class="active sidebar-link">贪心类型问题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>阅读笔记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="贪心类型问题"><a href="#贪心类型问题" class="header-anchor">#</a> 贪心类型问题</h1> <h2 id="贪心算法之区间调度问题"><a href="#贪心算法之区间调度问题" class="header-anchor">#</a> 贪心算法之区间调度问题</h2> <h3 id="什么是贪心算法"><a href="#什么是贪心算法" class="header-anchor">#</a> 什么是贪心算法</h3> <p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p> <p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p> <h3 id="贪心选择性质"><a href="#贪心选择性质" class="header-anchor">#</a> 贪心选择性质</h3> <p>每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p> <p>然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决，参见前文「动态规划解决博弈问题」。</p> <h3 id="一、问题描述"><a href="#一、问题描述" class="header-anchor">#</a> 一、问题描述</h3> <p>经典的贪心算法问题 Interval Scheduling（区间调度问题）：</p> <p>给你很多形如 <code>[start, end]</code> 的闭区间，请你设计一个算法，<strong>算出这些区间中最多有几个互不相交的区间</strong>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">intervalSchedule</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intvs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p> <p>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 <code>[start, end]</code> 表示开始和结束的时间，请问你今天**最多能参加几个活动呢？**显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。</p> <h3 id="二、贪心算法"><a href="#二、贪心算法" class="header-anchor">#</a> 二、贪心算法</h3> <p>也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。</p> <h4 id="正确的思路"><a href="#正确的思路" class="header-anchor">#</a> 正确的思路</h4> <ol><li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中<strong>结束最早的</strong>（end 最小）。</li> <li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li> <li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">intervalSchedule</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intvs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>intvs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 按 end 升序排序</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intvs<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 至少有一个区间不相交</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 排序后，第一个区间就是 x</span>
    <span class="token keyword">int</span> x_end <span class="token operator">=</span> intvs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interval <span class="token operator">:</span> intvs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> start <span class="token operator">=</span> interval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&gt;=</span> x_end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 找到下一个选择的区间了</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
            x_end <span class="token operator">=</span> interval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="三、应用举例"><a href="#三、应用举例" class="header-anchor">#</a> <strong>三、应用举例</strong></h3> <h4 id="leetcode-第-435-题-无重叠区间"><a href="#leetcode-第-435-题-无重叠区间" class="header-anchor">#</a> LeetCode 第 435 题，无重叠区间：</h4> <p><img src="/myBlog/assets/img/Untitled.1e302666.png" alt="Untitled"></p> <p>我们已经会求最多有几个区间不会重叠了，那么剩下的不就是至少需要去除的区间吗？</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">return</span> n <span class="token operator">-</span> <span class="token function">intervalSchedule</span><span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="leetcode-第-452-题-用最少的箭头射爆气球"><a href="#leetcode-第-452-题-用最少的箭头射爆气球" class="header-anchor">#</a> LeetCode 第 452 题，用最少的箭头射爆气球：</h3> <p><img src="/myBlog/assets/img/Untitled 1.363a5c67.png" alt="Untitled"></p> <p>其实稍微思考一下，这个问题和区间调度算法一模一样！如果最多有 <code>n</code> 个不重叠的区间，那么就至少需要 <code>n</code> 个箭头穿透所有区间：</p> <p><img src="/myBlog/assets/img/Untitled 2.dd269021.png" alt="Untitled"></p> <p>只是有一点不一样，在 <code>intervalSchedule</code> 算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：</p> <p>只是有一点不一样，在 <code>intervalSchedule</code> 算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：</p> <p>所以只要将之前的算法稍作修改，就是这道题目的答案：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intvs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interval <span class="token operator">:</span> intvs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> start <span class="token operator">=</span> interval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 把 &gt;= 改成 &gt; 就行了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&gt;</span> x_end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
            x_end <span class="token operator">=</span> interval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这么做的原因也不难理解，因为现在边界接触也算重叠，所以 <code>start == x_end</code> 时不能更新 x。</p> <h2 id="扫描线技巧-安排会议室"><a href="#扫描线技巧-安排会议室" class="header-anchor">#</a> 扫描线技巧：安排会议室</h2> <p>力扣第 253 题 <strong><a href="https://leetcode.cn/problems/meeting-rooms-ii/" target="_blank" rel="noopener noreferrer">会议室 II<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></p> <p>给你输入若干形如 <code>[begin, end]</code> 的区间，代表若干会议的开始时间和结束时间，请你计算至少需要申请多少间会议室。</p> <p>函数签名如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 返回需要申请的会议室数量</span>
<span class="token keyword">int</span> <span class="token function">minMeetingRooms</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> meetings<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>如果把每个会议的起始时间看做一个线段区间，那么题目就是让你求最多有几个重叠区间</strong></p> <p>对于这种时间安排的问题，本质上讲就是区间调度问题，十有八九得排序，然后找规律来解决。****</p> <h3 id="题目延伸"><a href="#题目延伸" class="header-anchor">#</a> <strong><strong>题目延伸</strong></strong></h3> <ul><li><strong>第一个场景</strong>，假设现在只有一个会议室，还有若干会议，你如何将尽可能多的会议安排到这个会议室里？
这个问题需要将这些会议（区间）按结束时间（右端点）排序，然后进行处理，详见前文 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247485087&amp;idx=2&amp;sn=e74bdfdae607939a169295f7f95eff7a&amp;chksm=9bd7f897aca071814fc20fe6915c9d99debeeebffa49dda8bad79fee720738c0b1b2de3ea762&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">贪心算法做时间管理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li><strong>第二个场景</strong>，给你若干较短的视频片段，和一个较长的视频片段，请你从较短的片段中尽可能少地挑出一些片段，拼接出较长的这个片段。
这个问题需要将这些视频片段（区间）按开始时间（左端点）排序，然后进行处理，详见前文 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247491102&amp;idx=1&amp;sn=755633b7d225970135cd6c8b2f500a27&amp;chksm=9bd7e016aca0690025a1cf54812732ac1042fda44eacf1284371236b62d484eeee80b5d70537&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">剪视频剪出一个贪心算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li><strong>第三个场景</strong>，给你若干区间，其中可能有些区间比较短，被其他区间完全覆盖住了，请你删除这些被覆盖的区间。
这个问题需要将这些区间按左端点排序，然后就能找到并删除那些被完全覆盖的区间了，详见前文 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487316&amp;idx=1&amp;sn=95cfbbd24f1cb5d8c07c71c2ba15246a&amp;chksm=9bd7f15caca0784ab7bce7f36a6eb9118de2a573515a99948168ed93b25069a3b7bf85cf50a5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">删除覆盖区间<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li><strong>第四个场景</strong>，给你若干区间，请你将所有有重叠部分的区间进行合并。
这个问题需要将这些区间按左端点排序，方便找出存在重叠的区间，详见前文 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487316&amp;idx=1&amp;sn=95cfbbd24f1cb5d8c07c71c2ba15246a&amp;chksm=9bd7f15caca0784ab7bce7f36a6eb9118de2a573515a99948168ed93b25069a3b7bf85cf50a5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">合并重叠区间<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li><strong>第五个场景</strong>，有两个部门同时预约了同一个会议室的若干时间段，请你计算会议室的冲突时段。
这个问题就是给你两组区间列表，请你找出这两组区间的交集，这需要你将这些区间按左端点排序，详见前文 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487316&amp;idx=1&amp;sn=95cfbbd24f1cb5d8c07c71c2ba15246a&amp;chksm=9bd7f15caca0784ab7bce7f36a6eb9118de2a573515a99948168ed93b25069a3b7bf85cf50a5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">区间交集问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li><strong>第六个场景</strong>，假设现在只有一个会议室，还有若干会议，如何安排会议才能使这个会议室的闲置时间最少？
这个问题需要动动脑筋，说白了这就是个 0-1 背包问题的变形：
会议室可以看做一个背包，每个会议可以看做一个物品，物品的价值就是会议的时长，请问你如何选择物品（会议）才能最大化背包中的价值（会议室的使用时长）？
当然，这里背包的约束不是一个最大重量，而是各个物品（会议）不能互相冲突。把各个会议按照结束时间进行排序，然后参考前文 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247491184&amp;idx=2&amp;sn=8893a65d23d92c3b18c7abf62c2e88ba&amp;chksm=9bd7e078aca0696e2352d1c60bff9182969983712664e2e94450d8206a47f260b65ac63ec828&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">0-1 背包问题详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的思路即可解决，等我以后有机会可以写一写这个问题。</li> <li><strong>第七个场景</strong>，就是本文想讲的场景，给你若干会议，让你合理申请会议室。
好了，举例了这么多，来看看今天的这个问题如何解决。</li></ul> <h3 id="题目分析"><a href="#题目分析" class="header-anchor">#</a> 题目分析</h3> <p><strong>给你输入若干时间区间，让你计算同一时刻「最多」有几个区间重叠</strong>。</p> <p>题目的关键点在于，给你任意一个时刻，你是否能够说出这个时刻有几个会议在同时进行？</p> <p>如果可以做到，那我遍历所有的时刻，找个最大值，就是需要申请的会议室数量。</p> <p>有没有一种数据结构或者算法，给我输入若干区间，我能知道每个位置有多少个区间重叠？</p> <p>老读者肯定可以联想到之前说过的一个算法技巧：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487011&amp;idx=1&amp;sn=5e2b00c1c736fd7afbf3ed35edc4aeec&amp;chksm=9bd7f02baca0793d569a9633cc14117e708ccc9eb41b7f0add430ea78f22e4f2443f421c6841&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">差分数组技巧<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>把时间线想象成一个初始值为 0 的数组，每个时间区间<code>[i, j]</code>就相当于一个子数组，这个时间区间有一个会议，那我就把这个子数组中的元素都加一。</p> <p>最后，每个时刻有几个会议我不就知道了吗？我遍历整个数组，不就知道至少需要几间会议室了吗？</p> <p>举例来说，如果输入<code>meetings = [[0,30],[5,10],[15,20]]</code>，那么我们就给数组中<code>[0,30],[5,10],[15,20]</code>这几个索引区间分别加一，最后遍历数组，求个最大值就行了。</p> <p>还记得吗，差分数组技巧可以在 O(1) 时间对整个区间的元素进行加减，所以可以拿来解决这道题。</p> <p>不过，这个解法的效率不算高，所以我这里不准备具体写差分数组的解法，参照 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487011&amp;idx=1&amp;sn=5e2b00c1c736fd7afbf3ed35edc4aeec&amp;chksm=9bd7f02baca0793d569a9633cc14117e708ccc9eb41b7f0add430ea78f22e4f2443f421c6841&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">差分数组技巧<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的原理，有兴趣的读者可以自己尝试去实现。</p> <p><strong>基于差分数组的思路，我们可以推导出一种更高效，更优雅的解法</strong>。</p> <p>我们首先把这些会议的时间区间进行投影：</p> <p><img src="/myBlog/assets/img/Untitled 3.ec7d9fdc.png" alt="Untitled"></p> <p>红色的点代表每个会议的开始时间点，绿色的点代表每个会议的结束时间点。</p> <p>现在假想有一条带着计数器的线，在时间线上从左至右进行扫描，每遇到红色的点，计数器<code>count</code>加一，每遇到绿色的点，计数器<code>count</code>减一：</p> <p><img src="/myBlog/assets/img/Untitled 4.6139e5ce.png" alt="Untitled"></p> <p><strong>这样一来，每个时刻有多少个会议在同时进行，就是计数器<code>count</code>的值，<code>count</code>的最大值，就是需要申请的会议室数量</strong>。</p> <p>对差分数组技巧熟悉的读者一眼就能看出来了，这个扫描线其实就是差分数组的遍历过程，所以我们说这是差分数组技巧衍生出来的解法。</p> <h3 id="代码实现"><a href="#代码实现" class="header-anchor">#</a> 代码实现</h3> <p>首先，对区间进行投影，就相当于对每个区间的起点和终点分别进行排序：</p> <p><img src="/myBlog/assets/img/Untitled 5.3e579275.png" alt="Untitled"></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">minMeetingRooms</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> meetings<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> meetings<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> begin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 把左端点和右端点单独拿出来</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        begin<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> meetings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        end<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> meetings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 排序后就是图中的红点</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 排序后就是图中的绿点</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后就简单了，扫描线从左向右前进，遇到红点就对计数器加一，遇到绿点就对计数器减一，计数器<code>count</code>的最大值就是答案：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">minMeetingRooms</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> meetings<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> meetings<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> begin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        begin<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> meetings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        end<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> meetings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 扫描过程中的计数器</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 双指针技巧</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>begin<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> end<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 扫描到一个红点</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 扫描到一个绿点</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 记录扫描过程中的最大值</span>
        res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里使用的是 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247488584&amp;idx=1&amp;sn=90f7956fd9d8320fcb81aaf33c3fe7f1&amp;chksm=9bd7ea40aca06356cdb87ba86518c50646b48b8534d42625ba454c084187400b979c8d736a61&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">双指针技巧<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，你可以认为指针 i 就是那根扫描线，根据<code>i, j</code>的相对位置就可以模拟扫描线前进的过程。</p> <p>至此，这道题就做完了。当然，这个题目也可以变形，比如给你若干会议，问你<code>k</code>个会议室够不够用，其实你套用本文的解法代码，也可以很轻松解决。</p> <p>#@ <strong><strong>剪视频剪出一个贪心算法</strong></strong></p> <p>力扣第 1024 题「视频拼接」</p> <p><img src="/myBlog/assets/img/Untitled 6.dee9308e.png" alt="Untitled"></p> <p>函数签名如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">videoStitching</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> clips<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="思路分析"><a href="#思路分析" class="header-anchor">#</a> 思路分析</h3> <p>**区间问题肯定按照区间的起点或者终点进行排序。**因为排序之后更容易找到相邻区间之间的联系，如果是求最值的问题，可以使用贪心算法进行求解。</p> <p>至于到底如何排序，这个就要因题而异了，我做这道题的思路是先按照起点升序排序，如果起点相同的话按照终点降序排序。</p> <p>为什么这样排序呢，主要考虑到这道题的以下两个特点：</p> <p>1、要用若干短视频凑出完成视频<code>[0, T]</code>，至少得有一个短视频的起点是 0。</p> <p>这个很好理解，如果没有一个短视频是从 0 开始的，那么区间<code>[0, T]</code>肯定是凑不出来的。</p> <p>2、如果有几个短视频的起点都相同，那么一定应该选择那个最长（终点最大）的视频。</p> <p>这一条就是贪心的策略，因为题目让我们计算最少需要的短视频个数，如果起点相同，那肯定是越长越好，不要白不要，多出来了大不了剪辑掉嘛。</p> <p><img src="/myBlog/assets/img/Untitled 7.d47f40ff.png" alt="Untitled"></p> <p>当我们确定<code>clips[0]</code>一定会被选择之后，就可以选出第二个会被选择的视频：</p> <p><img src="/myBlog/assets/img/Untitled 8.7cf297dd.png" alt="Untitled"></p> <p><strong>我们会比较所有起点小于<code>clips[0][1]</code>的区间，根据贪心策略，它们中终点最大的那个区间就是第二个会被选中的视频</strong>。</p> <p>然后可以通过第二个视频区间贪心选择出第三个视频，以此类推，直到覆盖区间<code>[0, T]</code>，或者无法覆盖返回 -1。</p> <h3 id="代码实现-2"><a href="#代码实现-2" class="header-anchor">#</a> 代码实现</h3> <p>实现上述思路需要我们用两个变量<code>curEnd</code>和<code>nextEnd</code>来进行：</p> <p><img src="https://ask.qcloudimg.com/http-save/yehe-7432945/697454bd6e81cb3576da10298cda02fa.gif" alt="https://ask.qcloudimg.com/http-save/yehe-7432945/697454bd6e81cb3576da10298cda02fa.gif"></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">videoStitching</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> clips<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 按起点升序排列，起点相同的降序排列</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>clips<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 记录选择的短视频个数</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> curEnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nextEnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> clips<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> clips<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> curEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在第 res 个视频的区间内贪心选择下一个视频</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> clips<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> curEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            nextEnd <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nextEnd<span class="token punctuation">,</span> clips<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 找到下一个视频，更新 curEnd</span>
        res<span class="token operator">++</span><span class="token punctuation">;</span>
        curEnd <span class="token operator">=</span> nextEnd<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curEnd <span class="token operator">&gt;=</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 已经可以拼出区间 [0, T]</span>
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 无法连续拼出区间 [0, T]</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码的时间复杂度是多少呢？虽然代码中有一个嵌套的 while 循环，但这个嵌套 while 循环的时间复杂度是<code>O(N)</code>。因为当<code>i</code>递增到<code>n</code>时循环就会结束，所以这段代码只会执行<code>O(N)</code>次。</p> <p>但是别忘了我们对<code>clips</code>数组进行了一次排序，消耗了<code>O(NlogN)</code>的时间，所以本算法的总时间复杂度是<code>O(NlogN)</code>。</p> <h2 id="如何运用贪心思想玩跳跃游戏"><a href="#如何运用贪心思想玩跳跃游戏" class="header-anchor">#</a> 如何运用贪心思想玩跳跃游戏</h2> <h3 id="leetcode-第-55-题-跳跃游戏i"><a href="#leetcode-第-55-题-跳跃游戏i" class="header-anchor">#</a> LeetCode 第 55 题 跳跃游戏I</h3> <p><img src="/myBlog/assets/img/Untitled 9.f746122d.png" alt="Untitled"></p> <p><strong>不知道读者有没有发现，有关动态规划的问题，大多是让你求最值的</strong>，比如最长子序列，最小编辑距离，最长公共子串等等等。这就是规律，因为动态规划本身就是运筹学里的一种求最值的算法。</p> <p>那么贪心算法作为特殊的动态规划也是一样，也一定是让你求个最值。这道题表面上不是求最值，但是可以改一改：</p> <p><strong>请问通过题目中的跳跃规则，最多能跳多远</strong>？如果能够越过最后一格，返回 true，否则返回 false。</p> <p>所以说，这道题肯定可以用动态规划求解的。但是由于它比较简单，下一道题再用动态规划和贪心思路进行对比，现在直接上贪心的思路：</p> <div class="language-java extra-class"><pre class="language-java"><code>bool <span class="token function">canJump</span><span class="token punctuation">(</span>vector<span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> farthest <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不断计算能跳到的最远距离</span>
        farthest <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>farthest<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 可能碰到了 0，卡住跳不动了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>farthest <span class="token operator">&lt;=</span> i<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> farthest <span class="token operator">&gt;=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你别说，如果之前没有做过类似的题目，还真不一定能够想出来这个解法。每一步都计算一下从当前位置最远能够跳到哪里，然后和一个全局最优的最远位置 <code>farthest</code> 做对比，通过每一步的最优解，更新全局最优解，这就是贪心。</p> <h3 id="leetcode-第-45-题-跳跃游戏ii"><a href="#leetcode-第-45-题-跳跃游戏ii" class="header-anchor">#</a> LeetCode 第 45 题 跳跃游戏II</h3> <p><img src="/myBlog/assets/img/Untitled 10.c702cf2d.png" alt="Untitled"></p> <p><strong>现在的问题是，保证你一定可以跳到最后一格，请问你最少要跳多少次，才能跳过去</strong>。</p> <p>我们先来说说动态规划的思路，采用自顶向下的递归动态规划，可以这样定义一个 <code>dp</code> 函数：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步</span>
<span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span>vector<span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们想求的结果就是 <code>dp(nums, 0)</code>，base case 就是当 <code>p</code> 超过最后一格时，不需要跳跃：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&gt;=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>根据前文 <a href="https://labuladong.gitbook.io/algo" target="_blank" rel="noopener noreferrer">动态规划套路详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的动规框架，就可以暴力穷举所有可能的跳法，通过备忘录 <code>memo</code> 消除重叠子问题，取其中的最小值最为最终答案：</p> <div class="language-java extra-class"><pre class="language-java"><code>vector<span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> memo<span class="token punctuation">;</span>
<span class="token comment">// 主函数</span>
<span class="token keyword">int</span> <span class="token function">jump</span><span class="token punctuation">(</span>vector<span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 备忘录都初始化为 n，相当于 INT_MAX</span>
    <span class="token comment">// 因为从 0 调到 n - 1 最多 n - 1 步</span>
    memo <span class="token operator">=</span> vector<span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span>vector<span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// base case</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&gt;=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 子问题已经计算过</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> steps <span class="token operator">=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 你可以选择跳 1 步，2 步...</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> steps<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 穷举每一个选择</span>
        <span class="token comment">// 计算每一个子问题的结果</span>
        <span class="token keyword">int</span> subProblem <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 取其中最小的作为最终结果</span>
        memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> subProblem <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个动态规划应该很明显了，按照前文 <a href="https://labuladong.gitbook.io/algo" target="_blank" rel="noopener noreferrer">动态规划套路详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 所说的套路，状态就是当前所站立的索引 <code>p</code>，选择就是可以跳出的步数。</p> <p>该算法的时间复杂度是 递归深度 × 每次递归需要的时间复杂度，即 O(N^2)，在 LeetCode 上是无法通过所有用例的，会超时。</p> <p><strong>贪心算法比动态规划多了一个性质：贪心选择性质</strong>。我知道大家都不喜欢看严谨但枯燥的数学形式定义，那么我们就来直观地看一看什么样的问题满足贪心选择性质。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> steps <span class="token operator">=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 你可以选择跳 1 步，2 步...</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> steps<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 计算每一个子问题的结果</span>
        <span class="token keyword">int</span> subProblem <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>subProblem <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>for 循环中会陷入递归计算子问题，这是动态规划时间复杂度高的根本原因。</p> <p>但是，真的需要【递归地】计算出每一个子问题的结果，然后求最值吗？<strong>直观地想一想，似乎不需要递归，只需要判断哪一个选择最具有【潜力】即可</strong>：</p> <p><img src="/myBlog/assets/img/Untitled 11.cc773c25.png" alt="Untitled"></p> <p>比如上图这种情况，我们站在索引 0 的位置，可以向前跳 1，2 或 3 步，你说应该选择跳多少呢？</p> <p><strong>显然应该跳 2 步调到索引 2，因为 <code>nums[2]</code> 的可跳跃区域涵盖了索引区间 <code>[3..6]</code>，比其他的都大</strong>。如果想求最少的跳跃次数，那么往索引 2 跳必然是最优的选择。</p> <p>你看，<strong>这就是贪心选择性质，我们不需要【递归地】计算出所有选择的具体结果然后比较求最值，而只需要做出那个最有【潜力】，看起来最优的选择即可</strong>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">jump</span><span class="token punctuation">(</span>vector<span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> farthest <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> jumps <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        farthest <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> farthest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            jumps<span class="token operator">++</span><span class="token punctuation">;</span>
            end <span class="token operator">=</span> farthest<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> jumps<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结合刚才那个图，就知道这段短小精悍的代码在干什么了：</p> <p><img src="/myBlog/assets/img/Untitled 12.d5620914.png" alt="Untitled"></p> <p><code>i</code> 和 <code>end</code> 标记了可以选择的跳跃步数，<code>farthest</code> 标记了所有选择 <code>[i..end]</code> 中能够跳到的最远距离，<code>jumps</code> 记录了跳跃次数。</p> <p>本算法的时间复杂度 O(N)，空间复杂度 O(1)，可以说是非常高效，动态规划都被吊起来打了。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/myBlog/数据结构与算法/3.DP.html" class="prev">
        动态规划（Dynamic Programming）
      </a></span> <span class="next"><a href="/myBlog/编程笔记/JavaScript 常用技巧.html">
        JavaScript 常用技巧
      </a>
      →
    </span></p></div> </main> <div class="sidebar article-directories"><h3 class="header">目录</h3> <a href="/myBlog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4.greedy.html#贪心算法之区间调度问题" class="dir-item"><span>贪心算法之区间调度问题</span></a><a href="/myBlog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4.greedy.html#扫描线技巧-安排会议室" class="dir-item"><span>扫描线技巧：安排会议室</span></a><a href="/myBlog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4.greedy.html#如何运用贪心思想玩跳跃游戏" class="dir-item"><span>如何运用贪心思想玩跳跃游戏</span></a></div></div><div class="global-ui"></div></div>
    <script src="/myBlog/assets/js/app.726a4394.js" defer></script><script src="/myBlog/assets/js/3.1a3b197f.js" defer></script><script src="/myBlog/assets/js/2.a46ddd04.js" defer></script><script src="/myBlog/assets/js/1.122429d8.js" defer></script><script src="/myBlog/assets/js/12.4e24e4ef.js" defer></script>
  </body>
</html>
